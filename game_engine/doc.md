# 游戏规则

@../docs/GAME_RULES.md

# 七圣召唤游戏引擎技术文档

## 1. 系统架构概述

### 1.1 整体架构

七圣召唤游戏引擎采用分层架构设计，主要包括：

- **表现层**：前端UI和WebSocket接口
- **服务层**：Flask API和业务逻辑
- **引擎层**：游戏核心引擎
- **数据层**：数据库和数据访问层

### 1.2 核心组件

- **GameEngine**：核心游戏引擎，处理游戏状态变更
- **ElementReactionSystem**：元素反应处理
- **DeckValidationSystem**：卡组验证
- **AIDecisionEngine**：AI决策引擎
- **GameStateManager**：游戏状态管理

## 2. 技术栈

### 2.1 后端技术

- **Python 3.12+**：主开发语言
- **Flask**：Web框架
- **Flask-SocketIO**：实时通信
- **SQLAlchemy**：ORM框架
- **PostgreSQL/SQLite**：数据库
- **PyJWT**：用户认证
- **pytest**：测试框架

### 2.2 数据结构设计

#### 2.2.1 游戏操作定义

```python
class PlayerAction(Enum):
    PLAY_CARD = "play_card"
    USE_SKILL = "use_skill"
    SWITCH_CHARACTER = "switch_character"
    PASS_TURN = "pass_turn"
    ELEMENTAL_TUNING = "elemental_tuning"
    REROLL_DICE = "reroll_dice"
    REPLACE_CARDS = "replace_cards"
```

#### 2.2.2 数据库模型

- **GameHistory**: 游戏历史记录
- **GameActionLog**: 游戏操作日志
- **ReplayData**: 回放数据
- **GameStateSnapshot**: 游戏状态快照

## 3. 游戏引擎设计

### 3.1 GameEngine类设计

```python
class GameEngine:
    def __init__(self):
        self.game_states: Dict[str, GameState] = {}
        self.element_reaction_system = ElementReactionSystem()
        self.deck_validation_system = DeckValidationSystem()
        
    def create_game_state(self, player1_id, player2_id, deck1, deck2) -> str:
        """创建新的游戏状态"""
        
    def process_action(self, game_id, player_id, action, payload) -> Optional[GameState]:
        """处理玩家操作"""
        
    def get_game_state(self, game_id) -> Optional[GameState]:
        """获取游戏状态"""
        
    def end_game(self, game_id, winner_id) -> None:
        """结束游戏"""
```

### 3.2 GameState数据结构

```python
@dataclass
class GameState:
    players: List[PlayerState]
    current_player_index: int
    round_number: int
    phase: GamePhase
    game_log: List[str]
    is_game_over: bool
    winner: Optional[str]
```

## 4. API接口设计

### 4.1 游戏会话API

- `POST /api/game_sessions` - 创建游戏会话
- `GET /api/game_sessions/{game_session_id}` - 获取游戏状态
- `POST /api/game_sessions/{game_session_id}/actions` - 提交玩家操作
- `POST /api/game_sessions/{game_session_id}/end` - 结束游戏

### 4.2 回放API

- `GET /api/replays` - 获取回放列表
- `GET /api/replays/{replay_id}` - 获取特定回放
- `GET /api/replays/{replay_id}/play` - 播放回放

### 4.3 观战API

- `POST /api/spectator/{game_session_id}/join` - 加入观战
- `GET /api/spectator/active_games` - 获取可观看游戏
- `POST /api/spectator/{game_session_id}/leave` - 离开观战

## 5. 实时通信设计

### 5.1 WebSocket接口

- **游戏更新命名空间**: `/game_updates`
  - `on_join_game` - 加入游戏房间
  - `on_game_action` - 处理玩家操作
  - `on_game_state_update` - 推送状态更新

- **观战命名空间**: `/spectator`
  - `on_join_spectate` - 加入观战
  - `on_spectator_initial_state` - 发送初始观战状态

## 6. AI对弈系统

### 6.1 AI决策引擎

- **策略选择器**: 根据难度选择不同策略
- **状态评估器**: 评估当前游戏状态价值
- **行动生成器**: 生成可能的行动选项

### 6.2 AI难度级别

- **Easy**: 基于随机和简单规则
- **Normal**: 基于强化规则的策略
- **Hard**: 使用搜索算法（如极小极大）
- **Expert**: 结合神经网络和高级搜索

## 7. 安全设计

### 7.1 认证与授权

- JWT令牌认证
- 操作权限验证
- 游戏会话权限检查

### 7.2 数据安全

- 观战模式信息过滤
- 操作输入验证
- 防止恶意操作

# 七圣召唤游戏引擎实施计划

## 1. 项目概述

本项目旨在实现七圣召唤游戏引擎，包括核心游戏逻辑、多人对战、AI对弈、回放和观战功能。项目采用分阶段实施方式，确保功能完整性和系统稳定性。

## 2. 实施阶段

### 2.1 第一阶段：核心游戏引擎完善 (Week 1-2)

#### 2.1.1 任务目标

完善现有游戏引擎，实现完整的七圣召唤游戏规则

#### 2.1.2 具体任务

- **完善回合流程实现**
  - 完成行动阶段所有操作类型
  - 优化结束阶段效果处理
  - 实现回合切换和先手判定
- **元素反应系统增强**
  - 实现所有官方元素反应效果
  - 集成反应优先级处理
  - 优化反应性能
- **卡牌效果处理**
  - 实现各类装备牌效果
  - 实现支援牌效果
  - 实现事件牌效果

#### 2.1.3 交付物

- 完整的 `game_engine/core.py`
- 单元测试覆盖率 > 80%
- 功能验证报告

#### 2.1.4 负责人员

- 游戏引擎开发：主开发人员
- 单元测试：QA工程师

### 2.2 第二阶段：数据模型与存储 (Week 2-3)

#### 2.2.1 任务目标

设计和实现游戏历史记录、操作日志、回放数据的存储方案

#### 2.2.2 具体任务

- **数据库模型设计**
  - GameHistory表：记录游戏元数据
  - GameActionLog表：记录每步操作
  - ReplayData表：存储完整回放
  - GameStateSnapshot表：存储游戏状态快照
- **数据访问层实现**
  - 实现对应的数据访问类
  - 编写数据库迁移脚本
  - 实现数据完整性约束

#### 2.2.3 交付物

- 完整的数据库模型定义
- 数据访问层实现
- 数据库迁移脚本

#### 2.2.4 负责人员

- 数据库设计：后端开发人员
- 数据访问层：后端开发人员

### 2.3 第三阶段：API接口开发 (Week 3-4)

#### 2.3.1 任务目标

实现所有必要的API接口，支持游戏全流程

#### 2.3.2 具体任务

- **游戏会话API**
  - 创建/获取/结束游戏会话
  - 提交玩家操作
  - 获取游戏状态
- **回放API**
  - 获取回放列表
  - 获取特定回放
  - 播放回放控制
- **观战API**
  - 观战权限管理
  - 观战连接管理
  - 实时观战状态更新

#### 2.3.3 交付物

- 完整的API实现
- API文档
- 接口测试用例

#### 2.3.4 负责人员

- API开发：后端开发人员
- API文档：技术文档工程师

### 2.4 第四阶段：实时通信 (Week 4-5)

#### 2.4.1 任务目标

实现WebSocket实时通信，支持游戏状态同步和观战功能

#### 2.4.2 具体任务

- **游戏状态同步**
  - 实现连接管理
  - 实现消息处理
  - 实现状态广播
- **观战实时通信**
  - 实现观战连接
  - 实现信息过滤
  - 实现观战状态同步

#### 2.4.3 交付物

- WebSocket处理器实现
- 实时通信测试报告
- 性能基准测试

#### 2.4.4 负责人员

- WebSocket实现：后端开发人员
- 性能测试：QA工程师

### 2.5 第五阶段：AI对弈系统 (Week 5-6)

#### 2.5.1 任务目标

实现AI对弈系统，支持不同难度级别

#### 2.5.2 具体任务

- **AI策略实现**
  - 基础策略（随机、规则）
  - 高级策略（极小极大、蒙特卡洛）
  - 策略选择与切换
- **AI决策引擎**
  - 游戏状态评估
  - 行动生成
  - 决策执行

#### 2.5.3 交付物

- AI引擎实现
- 多难度级别支持
- AI性能测试报告

#### 2.5.4 负责人员

- AI引擎开发：算法工程师
- AI测试：QA工程师

### 2.6 第六阶段：系统集成与优化 (Week 6-7)

#### 2.6.1 任务目标

整合所有模块，进行系统优化和测试

#### 2.6.2 具体任务

- **系统集成**
  - 各模块集成测试
  - 端到端流程验证
  - 错误处理完善
- **性能优化**
  - 数据库查询优化
  - 算法性能优化
  - 内存使用优化

#### 2.6.3 交付物

- 集成测试报告
- 性能优化报告
- 系统稳定性测试

#### 2.6.4 负责人员

- 系统集成：全栈开发人员
- 性能优化：系统架构师

## 3. 里程碑

### 3.1 里程碑1：核心引擎完成 (End of Week 2)

- 实现完整游戏规则
- 完成单元测试
- 内部演示

### 3.2 里程碑2：后端服务完成 (End of Week 4)

- API接口完成
- 数据存储完成
- WebSocket通信完成
- 基础功能演示

### 3.3 里程碑3：AI系统完成 (End of Week 5)

- AI对弈系统完成
- AI多难度支持
- AI功能演示

### 3.4 里程碑4：系统完成 (End of Week 7)

- 所有功能完成
- 集成测试完成
- 准备发布

# 七圣召唤游戏引擎测试计划

## 1. 测试策略概述

本测试计划旨在确保七圣召唤游戏引擎的正确性、稳定性、性能和安全性。采用分层测试策略，包括单元测试、集成测试、系统测试和验收测试。

## 2. 测试范围

### 2.1 功能测试

- 游戏规则实现验证
- 玩家操作处理
- AI对弈逻辑
- 回放功能
- 观战功能

### 2.2 非功能测试

- 性能测试
- 安全测试
- 兼容性测试
- 可用性测试

## 3. 测试类型

### 3.1 单元测试

#### 3.1.1 测试范围

- **游戏引擎模块**
  - `game_engine/core.py` - 游戏状态更新逻辑
  - `game_engine/element_reactions.py` - 元素反应逻辑
  - `game_engine/deck_validation.py` - 卡组验证逻辑
  - `game_engine/effects.py` - 游戏效果处理

- **数据访问层模块**
  - DAL类的CRUD操作
  - 数据库事务处理
  - 数据一致性验证

- **AI引擎模块**
  - AI策略选择
  - 决策算法准确性
  - 状态评估函数

#### 3.1.2 测试工具

- `pytest`: 单元测试框架
- `pytest-mock`: 依赖模拟
- `coverage`: 覆盖率分析

#### 3.1.3 目标指标

- 代码覆盖率 > 80%
- 所有核心逻辑路径覆盖
- 边界条件测试完整

#### 3.1.4 实施计划

1. 为每个功能模块编写测试用例
2. 执行单元测试
3. 分析覆盖率报告
4. 补充缺失测试
5. 重复直到达到覆盖率目标

### 3.2 集成测试

#### 3.2.1 测试范围

- **API端到端测试**
  - 游戏会话创建流程
  - 玩家操作处理流程
  - 游戏状态同步流程
  - 回放创建和播放流程

- **数据库集成测试**
  - 游戏历史记录存储
  - 操作日志记录
  - 回放数据存储与检索
  - 状态快照创建与应用

- **实时通信测试**
  - WebSocket连接建立
  - 消息传输验证
  - 状态同步准确性
  - 观战信息过滤

#### 3.2.2 测试工具

- `pytest`: 集成测试框架
- `requests`: API测试
- `mock`: 外部依赖模拟

#### 3.2.3 目标指标

- 所有关键业务流程测试
- API错误处理验证
- 数据库事务完整性

#### 3.2.4 实施计划

1. 搭建集成测试环境
2. 编写API测试用例
3. 执行数据库集成测试
4. 执行实时通信测试
5. 修复发现的问题

### 3.3 系统测试

#### 3.3.1 功能测试

- **完整游戏流程测试**
  - 从创建游戏到结束的全流程
  - 各种操作的正确性验证
  - 特殊规则处理验证（如元素反应、卡牌效果等）

- **AI对弈测试**
  - 不同难度AI的表现
  - AI决策的合理性
  - AI对弈稳定性
  - AI与人类玩家交互

- **观战功能测试**
  - 观战权限验证
  - 信息过滤准确性
  - 实时观战体验
  - 裁判模式验证

- **回放功能测试**
  - 回放记录完整性
  - 回放播放准确性
  - 快进、倒退功能
  - 关键节点标记

#### 3.3.2 性能测试

- **负载测试**
  - 10、50、100、500并发用户
  - 响应时间基准
  - 系统资源使用
  - 数据库性能

- **压力测试**
  - 高负载下的系统表现
  - 系统稳定性验证
  - 故障恢复能力
  - 内存泄漏检测

- **并发测试**
  - 多游戏同时进行
  - 多观战者同时观战
  - 操作并发处理

#### 3.3.3 安全测试

- **认证授权测试**
  - JWT令牌验证
  - 权限控制验证
  - 数据访问控制

- **输入验证测试**
  - 恶意输入处理
  - SQL注入防护
  - XSS防护
  - 操作频率限制

- **数据安全测试**
  - 观战模式信息过滤验证
  - 对手信息保护
  - 游戏状态完整性

#### 3.3.4 兼容性测试

- **浏览器兼容性**
  - Chrome, Firefox, Safari, Edge
- **网络环境测试**
  - 高延迟、低带宽环境

#### 3.3.5 测试工具

- `pytest`: 系统测试框架
- `locust`: 负载测试
- `OWASP ZAP`: 安全测试
- `selenium`: UI测试

#### 3.3.6 目标指标

- 95%功能测试通过率
- 响应时间 < 500ms (95%请求)
- 99%可用性
- 0安全漏洞

#### 3.3.7 实施计划

1. 准备测试环境
2. 执行功能测试
3. 执行性能测试
4. 执行安全测试
5. 生成测试报告

### 3.4 验收测试

#### 3.4.1 用户验收测试

- 邀请真实用户试用
- 功能完整性验证
- 用户体验评估
- 游戏平衡性验证

#### 3.4.2 业务验收测试

- 业务规则正确性
- 游戏流程完整性
- 与业务需求匹配度

#### 3.4.3 基准测试

- 与预期性能基准对比
- 功能完整性检查
- 准备发布验证

## 4. 测试数据管理

### 4.1 测试数据准备

- 准备不同类型的卡组数据
- 创建各种游戏场景数据
- 准备边界条件测试数据
- 准备AI测试数据集

### 4.2 测试环境

- 开发环境: 本地开发使用
- 测试环境: 自动化测试执行
- 预发布环境: 验收测试
- 生产环境: 发布后监控

### 4.3 数据清理

- 测试后数据清理
- 环境重置
- 测试数据保护

## 5. 测试报告

### 5.1 测试执行报告

- 测试用例执行统计
- 缺陷统计
- 通过/失败比率

### 5.2 性能测试报告

- 响应时间统计
- 负载测试结果
- 资源使用情况

### 5.3 安全测试报告

- 安全漏洞统计
- 风险评估
- 修复建议

## 6. 缺陷管理

### 6.1 缺陷分类

- 功能缺陷
- 性能缺陷
- 安全缺陷
- 用户体验缺陷

### 6.2 缺陷优先级

- Critical: 系统无法使用
- High: 核心功能失效
- Medium: 功能部分失效
- Low: 用户体验问题

### 6.3 缺陷追踪

- 使用缺陷管理工具记录
- 定期审查缺陷状态
- 确保缺陷及时修复

## 7. 测试环境要求

### 7.1 硬件要求

- CPU: 8核以上
- 内存: 16GB以上
- 存储: 500GB以上

### 7.2 软件要求

- 操作系统: Linux/Windows/macOS
- 数据库: PostgreSQL/SQLite
- Python: 3.12+
- 相关依赖包

### 7.3 网络要求

- 稳定的网络连接
- 充足的带宽支持
- 低延迟要求
