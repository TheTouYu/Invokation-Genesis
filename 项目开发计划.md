七圣召唤（Genshin Impact Card Game）项目可执行开发计划
阶段 0：准备工作 (第 0 周)

    环境搭建：安装 Python 3.12+、Node.js、Docker、PostgreSQL、Redis。
    依赖初始化：使用 uv 或 pip 安装后端依赖；使用 npm 安装前端依赖。
    代码仓库初始化：创建 Git 仓库，设置 .gitignore。
    数据导入：运行 fetch_and_save_cards.py 确保 card_data/ 目录下的 JSON 文件是最新的。
    前端环境准备：创建前端目录结构，初始化 React TypeScript 项目，安装前端依赖（Redux Toolkit, React Redux, Socket.io-client, Axios, Styled Components），配置基础类型定义、Redux store、API和WebSocket服务，并创建基础UI组件（Card, GameBoard, CharacterArea）。
     

阶段 1：基础建设 (第 1-2 周)

1.1 核心数据模型与数据库

    创建 models/enums.py，定义所有枚举类型（元素、卡牌类型、骰子类型等）。
    创建 models/game_models.py，实现 Card, CharacterCard, PlayerState, GameState 等核心数据类。
    创建 models/db_models.py，定义 User, Deck, CardData 等数据库模型。
    编写 init_db.py 脚本，将 card_data/ 目录下的 JSON 文件导入数据库。
     

1.2 用户认证系统

    实现 api/auth.py，完成用户注册、登录、获取个人信息的 API。
    集成 JWT 令牌认证。
     

1.3 项目骨架搭建

    按照规划的目录结构 (backend/, frontend/, docker/ 等) 创建项目文件夹。
    配置后端 app.py，集成 Flask、数据库、JWT 和路由。
    初始化前端 React 项目 (create-react-app)，配置基本路由。
     

阶段 2：单人游戏模式 (第 3-4 周)

2.1 游戏引擎核心

    创建 game_engine/core.py，实现 GameEngine 类。
    实现核心方法：create_game_state, process_action, _roll_phase, _action_phase, _end_phase。
    实现基础动作处理逻辑：_process_switch_action, _process_end_turn_action。
    实现基础的费用支付和验证逻辑 (_can_pay_cost, _pay_cost)。
     

2.2 卡牌与游戏 API

    实现 api/cards.py，提供 /api/cards/characters, /api/cards/events 等端点。
    实现 api/local_game.py，提供 /api/local-game/start 和 /api/local-game/<session_id>/action 端点。
    使用内存字典（如 game_sessions）临时存储单人游戏会话状态。
     

2.3 基础前端 UI

    创建 frontend/src/types/game.ts，定义前端 TypeScript 接口。
    搭建 GameBoard.tsx 的基本布局（对手区、中央区、玩家区）。
    创建 Card.tsx 组件，用于展示卡牌的基本信息。
    实现一个简单的页面，调用后端 API 获取卡牌列表并展示。
     

阶段 3：多人游戏基础设施 (第 5-6 周)

3.1 WebSocket 通信

    集成 Flask-SocketIO 到后端。
    创建 socket_handlers/game_handler.py，实现 create_game, join_game, game_action 等 WebSocket 事件处理器。
    实现房间管理逻辑，确保消息只广播给游戏内的玩家。
     

3.2 匹配与游戏会话

    实现 api/matchmaking.py，提供 /api/matchmaking/queue 端点。
    实现简单的匹配逻辑（先到先得）。
    将游戏会话从内存字典迁移到更持久化的管理方式（可结合 Redis）。
     

3.3 前端实时通信

    创建 websocketService.ts，封装 WebSocket 连接、重连和消息处理逻辑。
    创建 useGameController.ts 自定义 Hook，封装 useSkill, switchCharacter, playCard 等游戏动作。
    修改 GameBoard.tsx，使其通过 WebSocket 与后端进行实时交互。
     

阶段 4：UI 与游戏交互逻辑完善 (第 7-9 周)

4.1 完整游戏界面

    完善 GameBoard.tsx，添加角色区域 (CharacterArea)、支援/召唤物区域、骰子区域、手牌区域和行动面板。
    实现游戏日志 (GameLog) 组件。
    添加游戏阶段（投掷、行动、结束）和回合数的显示。
     

4.2 游戏逻辑深度集成

    在 game_engine/core.py 中完善所有游戏机制：
        元素反应系统
        角色技能费用支付
        装备/天赋卡的附着逻辑
        召唤物和支援牌的触发逻辑
         
    在前端 gameLogic.ts 中实现 getAvailableActions 等辅助函数，动态计算玩家当前可执行的操作。
     

4.3 游戏流程闭环

    实现完整的回合流程：投骰 -> 行动 -> 结束 -> 下一回合。
    实现游戏初始化流程：选牌、换牌、选择首发角色。
     

阶段 5：多人游戏体验优化 (第 10-11 周)

5.1 连接与重连

    在后端实现 connection_manager.py，健壮地管理用户连接和断线重连。
    实现游戏状态恢复功能，确保玩家重连后能同步到最新状态。
     

5.2 胜负与观战

    实现 victory_conditions.py，处理角色击败、15回合平局等胜利条件。
    实现 api/spectate.py 和对应的 WebSocket 事件，支持观战功能。
     

5.3 数据持久化

    创建 GameHistory 数据库模型，记录每一场对局的详细信息。
    在游戏结束时，将对局结果写入数据库，并更新玩家的胜/负统计数据。
     

阶段 6：测试与部署 (第 12 周)

6.1 测试

    为 GameEngine 编写单元测试 (test_game_engine.py)。
    为后端 API 编写集成测试 (test_api.py)。
    进行手动端到端测试，确保核心游戏流程无阻塞 Bug。
     

6.2 部署

    编写 Dockerfile 和 docker-compose.yml，实现一键部署。
    配置 Nginx 作为反向代理，处理 HTTP 和 WebSocket 请求。
    配置 CI/CD 流水线（如 GitHub Actions），实现自动化测试和部署。
    （可选）配置 Prometheus + Grafana 进行应用监控。
     
